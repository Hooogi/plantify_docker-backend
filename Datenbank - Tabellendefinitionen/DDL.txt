#Definitionen der Tabellen und der Trigger

CREATE TABLE plant_pot
(
    pot_id INT PRIMARY KEY AUTO_INCREMENT,
    pot_mac VARCHAR(17) UNIQUE,
    pot_name VARCHAR(30) UNIQUE
);

CREATE TABLE sensor_reading
(
    reading_id      INT PRIMARY KEY AUTO_INCREMENT,
    pot_id          INT,
    created         TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    temperature     DECIMAL(3, 1),
    sunlight        TINYINT(1),
    air_humidity    DECIMAL(4, 1),
    soil_moisture DECIMAL(4, 1),
    UNIQUE KEY pot_time (pot_id, created),
    FOREIGN KEY (pot_id) REFERENCES plant_pot(pot_id) ON DELETE CASCADE
);

CREATE TABLE user_profile
(
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    user_mail VARCHAR(64) UNIQUE,
    password_hash VARCHAR(100)
);

CREATE TABLE user_pot_assignment
(
    pot_id INT,
    user_id INT,
    PRIMARY KEY(pot_id,user_id),
    FOREIGN KEY (pot_id) references plant_pot(pot_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) references user_profile(user_id) ON DELETE CASCADE
);

CREATE TABLE plant_profile
(
    plant_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(64),
    description VARCHAR(254),
    irrigation_cycle_days INT,
    target_temperature_celsius DECIMAL(3,1),
    target_sunlight_hours INT,
    target_air_humidity_percent DECIMAL(4,1),
    target_soil_moisture_percent DECIMAL(4,1)
);

CREATE TABLE plant_pot_assignment
(
    assignment_id INT PRIMARY KEY AUTO_INCREMENT,
    pot_id INT NOT NULL,
    plant_id INT NOT NULL,
    assigned_from TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_to TIMESTAMP DEFAULT NULL,
    FOREIGN KEY (pot_id) references plant_pot(pot_id) ON DELETE CASCADE,
    FOREIGN KEY (plant_id) references plant_profile(plant_id) ON DELETE CASCADE
);

DELIMITER //

CREATE TRIGGER prevent_duplicate_active_assignment
BEFORE INSERT ON plant_pot_assignment
FOR EACH ROW
BEGIN
  IF EXISTS (
    SELECT 1 FROM plant_pot_assignment
    WHERE pot_id = NEW.pot_id
      AND assigned_to IS NULL
  ) THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'Topf hat bereits eine aktive Zuweisung';
  END IF;
END;
//

CREATE TRIGGER prevent_duplicate_active_assignment_update
BEFORE UPDATE ON plant_pot_assignment
FOR EACH ROW
BEGIN
  IF NEW.assigned_to IS NULL AND OLD.assigned_to IS NOT NULL THEN
    IF EXISTS (
      SELECT 1 FROM plant_pot_assignment
      WHERE pot_id = NEW.pot_id AND assigned_to IS NULL AND assignment_id != NEW.assignment_id
    ) THEN
      SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Topf hat bereits eine aktive Zuweisung (Update verhindert)';
    END IF;
  END IF;
END;
//

CREATE TRIGGER assign_admin_user
AFTER INSERT ON plant_pot
FOR EACH ROW
BEGIN
  INSERT INTO user_pot_assignment (user_id, pot_id)
  SELECT user_id, NEW.pot_id
  FROM user_profile
  WHERE user_mail = 'admin@plantpot';
END //

DELIMITER ;

#Definitionen der Views

CREATE OR REPLACE VIEW viw_AverageMeasurements_MTD AS
SELECT
    sd.pot_id,
    DATE(sd.created),
    AVG(sd.temperature) AS avg_temperature,
    AVG(sh.HoS) AS avg_hours_of_sunlight,
    AVG(sd.air_humidity) AS avg_air_humidity,
    AVG(sd.ground_humidity) AS avg_ground_humidity
FROM
    sensor_data sd
JOIN
    viw_SunlightPerDay_last30Days sh ON sd.pot_id = sh.pot_id
WHERE
    sd.created >= DATE_FORMAT(NOW(), '%Y-%m-01')
GROUP BY
    sd.pot_id, DATE(sd.created);

CREATE OR REPLACE VIEW viw_SunlightPerDay_last30Days AS
SELECT
    sd.pot_id,
    DATE(sd.created) AS measurement_date,
    SUM(sd.sunlight) AS HoS
FROM
    sensor_data sd
WHERE
    sd.created >= DATE(NOW()) - INTERVAL 30 DAY
GROUP BY
    sd.pot_id, DATE(sd.created);

CREATE OR REPLACE VIEW viw_AllValues_Today AS
SELECT
    sd.pot_id,
    sd.temperature,
    sd.air_humidity,
    sd.ground_humidity,
    sd.created
FROM
    sensor_data sd
WHERE
    DATE(sd.created) = DATE(NOW());

CREATE OR REPLACE VIEW viw_LatestValuePerPot AS
SELECT
    sd.pot_id,
    sd.temperature,
    sd.ground_humidity,
    sd.air_humidity,
    sd.created
FROM
    sensor_data sd
JOIN (
    SELECT
        pot_id,
        MAX(created) AS created
    FROM
        sensor_data
    GROUP BY
        pot_id
) AS lpp
ON
    sd.pot_id = lpp.pot_id AND sd.created = lpp.created;
